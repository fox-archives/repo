{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Foxxy My task automator STATUS: IN DEVELOPMENT Contents I'm still developing this application, so there isn't a Getting Started guide. But, you can still read the Concepts and Motivation","title":"Foxxy"},{"location":"#foxxy","text":"My task automator STATUS: IN DEVELOPMENT","title":"Foxxy"},{"location":"#contents","text":"I'm still developing this application, so there isn't a Getting Started guide. But, you can still read the Concepts and Motivation","title":"Contents"},{"location":"commands/","text":"Commands init Initializes a new project in directory for a particular ecosystem lint Lints the configuration of a particular ecosystem. For example, it may check to ensure eslint-config-hyperupcall is installed, used, and update to date for a NodeJS application docs Generates documentation release Release a version for a particular ecosystem","title":"Commands"},{"location":"commands/#commands","text":"","title":"Commands"},{"location":"commands/#init","text":"Initializes a new project in directory for a particular ecosystem","title":"init"},{"location":"commands/#lint","text":"Lints the configuration of a particular ecosystem. For example, it may check to ensure eslint-config-hyperupcall is installed, used, and update to date for a NodeJS application","title":"lint"},{"location":"commands/#docs","text":"Generates documentation","title":"docs"},{"location":"commands/#release","text":"Release a version for a particular ecosystem","title":"release"},{"location":"concepts/","text":"Concepts Fox performs tasks for a particular project. With Fox, the tasks are automatically run based on two factors: ecosystem and form An ecosystem is what it sounds like; the following are examples: NodeJS Go VueJS C The form is how the project will be ran in the context of the ecosystem. It can either be: app lib Here, applications are tantamount to producers while libraries are tantamount to consumers In cases where either cannot be automatically detected, an error will be thrown","title":"Concepts"},{"location":"concepts/#concepts","text":"Fox performs tasks for a particular project. With Fox, the tasks are automatically run based on two factors: ecosystem and form An ecosystem is what it sounds like; the following are examples: NodeJS Go VueJS C The form is how the project will be ran in the context of the ecosystem. It can either be: app lib Here, applications are tantamount to producers while libraries are tantamount to consumers In cases where either cannot be automatically detected, an error will be thrown","title":"Concepts"},{"location":"getting-started/","text":"Getting Started A configuration file with your information is required Make sure to create a GitHub PAT as well At ~/.config/foxxy/config.json : { \"person\": { \"fullname\": \"Edwin Kofler\", \"email\": \"edwin@kofler.dev\", \"websiteURL\": \"edwinkofler.com\" }, \"github_token\": \"\", \"defaults\": { \"vcsOwner\": \"hyperupcall\" } }","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"A configuration file with your information is required Make sure to create a GitHub PAT as well At ~/.config/foxxy/config.json : { \"person\": { \"fullname\": \"Edwin Kofler\", \"email\": \"edwin@kofler.dev\", \"websiteURL\": \"edwinkofler.com\" }, \"github_token\": \"\", \"defaults\": { \"vcsOwner\": \"hyperupcall\" } }","title":"Getting Started"},{"location":"motivation/","text":"Motivation It's tough synchronizing configuration across multiple repositories. Configuration is necessary to maximize the benefits of using tools like EditorConfig , ESLint , Stylelint , and many others However, setting up configuration can be time consuming, and error-prone. It's something that can be automated. I first approached this problem by developing Glue . It had a number of problems: Coupling the task runner and the configuration manager. I thought this would make things more simple, but increased complexity since supposed-general-enough \"tasks\" would often need to be overridden on a per-repository Basis. With Foxxy, it interoperates with any task runner, such as with Bake , my home-grown one Authoring the software in Bash Originally, Glue was written in Bash, since it is highly portable (if carefully written) and terse. I understood the well-known deficiencies of Bash, but thought my existing experience would significantly mitigate the drawbacks. But, I ended up sidetracked writing a package manager for Bash , among other tools that wouldn't have been necessary in a different language Now implemented in Deno, things are trivial to modify. If Deno doesn't support an architecture I need to use, I'll simply refactor to Go","title":"Motivation"},{"location":"motivation/#motivation","text":"It's tough synchronizing configuration across multiple repositories. Configuration is necessary to maximize the benefits of using tools like EditorConfig , ESLint , Stylelint , and many others However, setting up configuration can be time consuming, and error-prone. It's something that can be automated. I first approached this problem by developing Glue . It had a number of problems: Coupling the task runner and the configuration manager. I thought this would make things more simple, but increased complexity since supposed-general-enough \"tasks\" would often need to be overridden on a per-repository Basis. With Foxxy, it interoperates with any task runner, such as with Bake , my home-grown one Authoring the software in Bash Originally, Glue was written in Bash, since it is highly portable (if carefully written) and terse. I understood the well-known deficiencies of Bash, but thought my existing experience would significantly mitigate the drawbacks. But, I ended up sidetracked writing a package manager for Bash , among other tools that wouldn't have been necessary in a different language Now implemented in Deno, things are trivial to modify. If Deno doesn't support an architecture I need to use, I'll simply refactor to Go","title":"Motivation"}]}